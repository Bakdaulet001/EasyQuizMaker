<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EasyQuizMaker - –¢–µ—Å—Ç —Å—ñ–∑–¥—ñ“£ –±—ñ–ª—ñ–º—ñ–Ω —Ç–µ–∫—Å–µ—Ä—É “Ø—à—ñ–Ω</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a202c 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        /* ===== INPUT SCREEN ===== */
        .input-screen {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            justify-content: center;
            padding: 20px;
        }

        .input-screen.hidden {
            display: none;
        }

        .input-container {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 30px 20px;
            backdrop-filter: blur(10px);
        }

        .input-container h1 {
            font-size: 28px;
            margin-bottom: 10px;
            text-align: center;
            color: #ffffff;
        }

        .input-container p {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 25px;
            font-size: 14px;
            line-height: 1.6;
        }

        textarea {
            width: 100%;
            min-height: 250px;
            padding: 15px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #10b981;
            color: white;
        }

        .btn-primary:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(16, 185, 129, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-next {
            background: #fbbf24;
            color: #0f1419;
        }

        .btn-next:hover {
            background: #f59e0b;
            transform: translateY(-2px);
        }

        /* Custom file upload button */
        .file-upload {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 6px;
        }

        .file-btn {
            display: inline-block;
            padding: 10px 14px;
            background: linear-gradient(90deg, #06b6d4 0%, #3b82f6 100%);
            color: #ffffff;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(59,130,246,0.18);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            border: none;
            font-size: 14px;
        }

        .file-btn:hover { transform: translateY(-2px); }

        .file-name {
            color: rgba(255,255,255,0.85);
            font-size: 13px;
            font-style: italic;
            max-width: 420px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        input[type="file"]#fileInput { display: none; }

        /* ===== QUIZ SCREEN ===== */
        .quiz-screen {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 15px 0;
        }

        .quiz-screen.hidden {
            display: none;
        }

        .quiz-header {
            background: rgba(15, 23, 42, 0.8);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .quiz-progress {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .quiz-stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-correct {
            color: #10b981;
            font-weight: 600;
        }

        .stat-incorrect {
            color: #ef4444;
            font-weight: 600;
        }

        .quiz-content {
            flex: 1;
            padding: 20px 15px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .question-container {
            margin-bottom: 30px;
        }

        .question-type-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            font-weight: 600;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            display: inline-block;
        }

        .question-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 25px;
            line-height: 1.5;
            color: #ffffff;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: #ffffff;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            user-select: none;
        }

        .option:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #10b981;
        }

        .option.selected {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .option.correct {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #10b981;
        }

        .option.incorrect {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
        }

        .option.disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        .feedback-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .feedback-message.show {
            display: block;
        }

        .feedback-correct {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 2px solid #10b981;
        }

        .feedback-incorrect {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 2px solid #ef4444;
        }

        .quiz-footer {
            padding: 15px;
            display: flex;
            gap: 10px;
        }

        .quiz-footer button {
            flex: 1;
        }

        /* ===== RESULTS SCREEN ===== */
        .results-screen {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 20px 15px;
        }

        .results-screen.hidden {
            display: none;
        }

        .results-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .results-header h1 {
            font-size: 28px;
            margin-bottom: 15px;
        }

        .results-score {
            font-size: 48px;
            font-weight: bold;
            color: #10b981;
            margin-bottom: 10px;
        }

        .results-subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
        }

        .results-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .result-item {
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
        }

        .result-item.correct {
            border-left-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .result-item.incorrect {
            border-left-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        .result-number {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .result-question {
            font-weight: 600;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .result-answer {
            margin-bottom: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-size: 14px;
        }

        .result-user-answer {
            color: #fbbf24;
        }

        .result-correct-answer {
            color: #10b981;
        }

        .result-unselected-answer {
            color: rgba(255, 255, 255, 0.6);
        }

        .result-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 18px;
        }

        .results-footer {
            padding: 15px 0;
        }

        .results-footer button {
            width: 100%;
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 600px) {
            body {
                padding: 8px;
            }

            .input-container {
                padding: 20px 15px;
            }

            .input-container h1 {
                font-size: 24px;
            }

            .question-text {
                font-size: 16px;
            }

            .quiz-header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .quiz-stats {
                width: 100%;
                justify-content: space-around;
            }

            .results-score {
                font-size: 36px;
            }

            .option {
                font-size: 14px;
                padding: 12px;
            }
        }

        @media (max-width: 480px) {
            .input-container h1 {
                font-size: 20px;
            }

            textarea {
                font-size: 13px;
                min-height: 200px;
            }

            button {
                font-size: 14px;
                padding: 12px 15px;
            }

            .quiz-content {
                padding: 15px 10px;
            }

            .question-text {
                font-size: 15px;
            }
        }

        /* ===== SCROLLBAR STYLING ===== */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* ===== MODAL DIALOG ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .modal-field {
            margin-bottom: 20px;
        }

        .modal-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .modal input[type="text"],
        .modal select {
            width: 100%;
            padding: 10px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #ffffff;
            font-size: 14px;
        }

        .modal input[type="text"]:focus,
        .modal select:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .modal input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            padding: 8px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .modal-buttons button {
            flex: 1;
        }

        /* ===== SAVED TESTS LIST ===== */
        .saved-tests-container {
            margin-bottom: 30px;
        }

        .saved-tests-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.9);
        }

        .saved-test-item {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .saved-test-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .saved-test-name {
            font-weight: 600;
            color: #10b981;
            font-size: 14px;
        }

        .saved-test-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 4px;
        }
    </style>
</head>
<body>

<div class="container">
    <!-- INPUT SCREEN -->
    <div class="input-screen" id="inputScreen">
        <div class="input-container">
            <h1>üìö EasyQuizMaker</h1>
            <p>XML —Ñ–æ—Ä–º–∞—Ç—ã–Ω–¥–∞“ì—ã —Å“±—Ä–∞“õ—Ç–∞—Ä–¥—ã —Ç”©–º–µ–Ω–≥–µ —Ç“Ø—Ä—ñ–∫ –µ—Ç—ñ“£—ñ–∑</p>
            <textarea id="questionsInput" placeholder="&lt;question&gt;...&lt;/question&gt;&#10;&lt;question2&gt;...&lt;/question2&gt;&#10;&lt;question3&gt;...&lt;/question3&gt;"></textarea>
            
            <!-- –°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã -->
            <div class="saved-tests-container" id="savedTestsContainer" style="display:none;">
                <div class="saved-tests-title">üìã –°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã:</div>
                <div id="savedTestsList"></div>
            </div>

            <!-- –°–ò–°–¢–ï–ú–ù–´–ï –¢–ï–°–¢–´ -->
            <div class="saved-tests-container" id="systemTestsContainer" style="margin-top:12px; display:none;">
                <div class="saved-tests-title">üñ•Ô∏è –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ç–µ—Å—Ç—ã:</div>
                <div id="systemTestsList"></div>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="openSettingsModal()">–¢–µ—Å—Ç—Ç—ñ –±–∞—Å–∞—É</button>
            </div>
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">‚öôÔ∏è –¢–µ—Å—Ç –ü–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ</div>

            <div class="modal-field">
                <label class="modal-label">–¢–µ—Å—Ç –∞—Ç–∞—É—ã:</label>
                <input type="text" id="testName" placeholder="–ú—ã—Å–∞–ª—ã: –ë–∏–æ–ª–æ–≥–∏—è 10-—Å—ã–Ω—ã–ø">
            </div>

            <div class="modal-field">
                <label class="modal-label">–°“±—Ä–∞“õ—Ç–∞—Ä —Å–∞–Ω—ã:</label>
                <select id="questionCount">
                    <option value="all">–ë–∞—Ä–ª—ã“ì—ã</option>
                    <option value="20">–ú–∞–∫—Å 20 —Ä–∞–Ω–¥–æ–º–Ω—ã —Å“±—Ä–∞“õ</option>
                    <option value="50">–ú–∞–∫—Å 50 —Ä–∞–Ω–¥–æ–º–Ω—ã —Å“±—Ä–∞“õ</option>
                </select>
            </div>

            <div class="modal-field">
                <label class="checkbox-group">
                    <input type="checkbox" id="autoAnswers"> –ê–≤—Ç–æ–º–∞—Ç—Ç—ã –∂–∞—É–∞–ø —Ä–µ–∂–∏–º—ñ
                </label>
                <div style="font-size:12px; color:rgba(255,255,255,0.6); margin-left:26px;">–î“±—Ä—ã—Å –∂–∞—É–∞–ø—Ç–∞—Ä–¥—ã —Ç“Ø—Å—ñ–Ω–¥—ñ—Ä—É</div>
            </div>

            <div class="modal-field">
                <button class="btn-secondary" onclick="openAnswerSelectionModal()" style="width:100%;">‚úì –î“±—Ä—ã—Å –∂–∞—É–∞–ø—Ç–∞—Ä–¥—ã —Ç–∞“£–¥–∞—É</button>
                <div style="font-size:12px; color:rgba(255,255,255,0.6); margin-top:8px; margin-left:0;" id="answerSelectionStatus">“ö–∞–∂–µ—Ç—Ç—ñ –µ–º–µ—Å - –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Å–∞“õ—Ç–∞—É</div>
            </div>

            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeSettingsModal()">–ë–∞—Å —Ç–∞—Ä—Ç—É</button>
                <button class="btn-primary" onclick="startQuizWithSettings()">–ë–∞—Å—Ç—É</button>
            </div>
        </div>
    </div>

    <!-- ANSWER SELECTION MODAL -->
    <div class="modal" id="answerSelectionModal">
        <div class="modal-content">
            <div class="modal-header">‚úì –î“±—Ä—ã—Å –∂–∞—É–∞–ø—Ç–∞—Ä–¥—ã —Ç–∞“£–¥–∞—É</div>
            <div id="answerSelectionContent" style="max-height:500px; overflow-y:auto;">
                <!-- –ó–∞–ø–æ–ª–Ω–∏—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
            </div>
            <div class="modal-buttons" style="margin-top:20px;">
                <button class="btn-secondary" onclick="closeAnswerSelectionModal()">–ë–∞—Å —Ç–∞—Ä—Ç—É</button>
                <button class="btn-primary" onclick="saveSelectedAnswers()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>
        </div>
    </div>

    <!-- QUIZ SCREEN -->
    <div class="quiz-screen hidden" id="quizScreen">
        <div class="quiz-header">
            <div class="quiz-progress">
                <span id="questionNumber">1</span> / <span id="totalQuestions">10</span>
            </div>
            <div class="quiz-stats">
                <div class="stat-item">
                    <span>‚úì</span>
                    <span class="stat-correct" id="correctCount">0</span>
                </div>
                <div class="stat-item">
                    <span>‚úó</span>
                    <span class="stat-incorrect" id="incorrectCount">0</span>
                </div>
            </div>
        </div>

        <div class="quiz-content">
            <div class="question-container">
                <div class="question-text" id="questionText"></div>
                <div class="options" id="optionsContainer"></div>
                <div class="feedback-message" id="feedbackMessage"></div>
            </div>

            <div class="quiz-footer">
                <button class="btn-secondary" onclick="goBack()">–ê—Ä—Ç“õ–∞</button>
                <button class="btn-secondary" id="skipBtn" style="display:none;" onclick="skipQuestion()">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
                <button class="btn-next" id="nextBtn" onclick="nextQuestion()">–ö–µ–ª–µ—Å—ñ —Å“±—Ä–∞“õ</button>
            </div>
        </div>
    </div>

    <!-- RESULTS SCREEN -->
    <div class="results-screen hidden" id="resultsScreen">
        <div class="results-header">
            <h1>üéâ –¢–µ—Å—Ç –∞—è“õ—Ç–∞–ª–¥—ã!</h1>
            <div class="results-score" id="finalScore">0/10</div>
            <div class="results-subtitle" id="resultMessage">–°—ñ–∑—ñ“£ –Ω”ô—Ç–∏–∂–µ“£—ñ–∑: 0%</div>
            <div id="resultsCounts" style="margin-top:8px; font-size:14px; color:rgba(255,255,255,0.8);">–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö: 0 ‚Ä¢ –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö: 0</div>
        </div>

        <div class="results-list" id="resultsList"></div>

        <div class="results-footer">
            <button class="btn-primary" onclick="restartQuiz()">“ö–∞–π—Ç–∞ –±–∞—Å—Ç–∞—É</button>
            <button id="retryWrongBtn" class="btn-secondary" onclick="retryWrongAnswers()" style="display:none; margin-top:10px; width:100%;">“ö–∞—Ç–µ —Å“±—Ä–∞“õ—Ç–∞—Ä–¥—ã “õ–∞–π—Ç–∞ ”©—Ç—É</button>
        </div>
    </div>
</div>

<script>
    // STATE MANAGEMENT
    let questions = [];
    let currentQuestionIndex = 0;
    let userAnswers = [];
    let answeredQuestions = 0;
    let questionAnswerStates = [];
    
    // Settings
    let testSettings = {
        testName: '',
        questionCount: 'all',
        autoAnswers: false,
        selectedAnswerOverrides: {}
    };
    let allParsedQuestions = [];
    let wrongQuestionIndices = [];
    let isRetryingWrongAnswers = false; // Track whether answer was submitted

    // PARSE XML FORMAT QUESTIONS
    function parseQuestions(text) {
        const questions = [];

        // Split by question tags (question, question2, question3)
        const lines = text.split('\n').map(l => l.trim()).filter(l => l);

        let currentQuestion = null;
        let currentType = null;

        function pushCurrentQuestion() {
            if (!currentQuestion) return;
            // For <question> type: if no variant was explicitly marked as correct (<variantright>),
            // default the first variant to correct. Do NOT blindly override existing isCorrect flags.
            if (currentQuestion.type === 'question') {
                const hasExplicit = currentQuestion.variants.some(v => v.isCorrect);
                if (!hasExplicit && currentQuestion.variants.length > 0) {
                    currentQuestion.variants[0].isCorrect = true;
                }
                currentQuestion.correctCount = currentQuestion.variants.filter(v => v.isCorrect).length;
            } else {
                currentQuestion.correctCount = currentQuestion.variants.filter(v => v.isCorrect).length;
            }
            questions.push(currentQuestion);
        }

        for (let line of lines) {
            // Check for question type markers
            if (line.startsWith('<question3>')) {
                if (currentQuestion) {
                    pushCurrentQuestion();
                }
                currentType = 'question3';
                currentQuestion = {
                    question: line.replace('<question3>', '').trim(),
                    variants: [],
                    type: 'question3',
                    correctCount: 0
                };
            } else if (line.startsWith('<question2>')) {
                if (currentQuestion) {
                    pushCurrentQuestion();
                }
                currentType = 'question2';
                currentQuestion = {
                    question: line.replace('<question2>', '').trim(),
                    variants: [],
                    type: 'question2',
                    correctCount: 0
                };
            } else if (line.startsWith('<question>')) {
                if (currentQuestion) {
                    pushCurrentQuestion();
                }
                currentType = 'question';
                    currentQuestion = {
                        question: line.replace('<question>', '').trim(),
                        variants: [],
                        type: 'question',
                        correctCount: 0
                    };
            } else if (line.startsWith('<variantright>')) {
                // Correct variant
                const variantText = line.replace('<variantright>', '').trim();
                if (currentQuestion && variantText) {
                    currentQuestion.variants.push({
                        text: variantText,
                        isCorrect: true
                    });
                    currentQuestion.correctCount++;
                }
            } else if (line.startsWith('<variant>')) {
                // Incorrect variant
                const variantText = line.replace('<variant>', '').trim();
                if (currentQuestion && variantText) {
                    currentQuestion.variants.push({
                        text: variantText,
                        isCorrect: false
                    });
                }
            }
        }

        // Finalize and add the last question if present
        if (currentQuestion) {
            pushCurrentQuestion();
        }

        return questions;
    }

    // TRY AUTO-LOAD TXT FILE FROM SAME DIRECTORY
    // –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∞ - –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞

    // ENSURE MINIMUM VARIANTS (–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–æ 5 –∏–∑ –¥—Ä—É–≥–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤)
    function ensureMinimumVariants(questions) {
        const minVariants = 5;
        const updatedQuestions = questions.map(q => ({
            ...q,
            variants: [...q.variants]
        }));

        // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ —Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        updatedQuestions.forEach((question, currentQIdx) => {
            if (question.variants.length < minVariants) {
                const neededCount = minVariants - question.variants.length;
                
                // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞
                const existingTexts = new Set(question.variants.map(v => v.text.toLowerCase().trim()));
                
                // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–∑ –î–†–£–ì–ò–• –≤–æ–ø—Ä–æ—Å–æ–≤ (–∏—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–∏–π)
                const otherVariants = [];
                updatedQuestions.forEach((otherQ, qIdx) => {
                    if (qIdx !== currentQIdx) { // –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å
                        otherQ.variants.forEach(variant => {
                            const variantTextLower = variant.text.toLowerCase().trim();
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ—Ç –≤–∞—Ä–∏–∞–Ω—Ç –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Ç–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å
                            if (!existingTexts.has(variantTextLower)) {
                                otherVariants.push({
                                    text: variant.text,
                                    isCorrect: false
                                });
                            }
                        });
                    }
                });

                // –°–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ (–±–µ–∑ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
                if (otherVariants.length > 0) {
                    const selectedVariants = [];
                    const shuffledOther = shuffle(otherVariants);
                    const selectedTexts = new Set(existingTexts);
                    
                    for (let i = 0; i < shuffledOther.length && selectedVariants.length < neededCount; i++) {
                        const variantTextLower = shuffledOther[i].text.toLowerCase().trim();
                        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ
                        if (!selectedTexts.has(variantTextLower)) {
                            selectedVariants.push({
                                text: shuffledOther[i].text,
                                isCorrect: false
                            });
                            selectedTexts.add(variantTextLower);
                        }
                    }
                    
                    question.variants = question.variants.concat(selectedVariants);
                }
            }
        });

        return updatedQuestions;
    }

    // SHUFFLE FUNCTION
    function shuffle(array) {
        const arr = [...array];
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // MODAL FUNCTIONS
    function openSettingsModal() {
        const input = document.getElementById('questionsInput').value.trim();
        if (!input) {
            alert('–°“±—Ä–∞“õ—Ç–∞—Ä–¥—ã –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑!');
            return;
        }

        allParsedQuestions = parseQuestions(input);
        if (allParsedQuestions.length === 0) {
            alert('–°“±—Ä–∞“õ—Ç–∞—Ä–¥—ã —Ç–∞–±—É –º“Ø–º–∫—ñ–Ω –±–æ–ª–º–∞–¥—ã!');
            return;
        }

        // –ï—Å–ª–∏ –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –≤–æ–ø—Ä–æ—Å–æ–≤, –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤–≤–æ–¥
        const qHash = hashQuestions(allParsedQuestions);
        const savedSettings = getSavedSettings(qHash);
        
        if (savedSettings) {
            testSettings = savedSettings;
            testSettings.selectedAnswerOverrides = savedSettings.selectedAnswerOverrides || {};
            startQuizWithSettings();
            return;
        }

        // –ò–Ω–∞—á–µ –ø–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ –Ω–∞—Å—Ç—Ä–æ–µ–∫
        document.getElementById('settingsModal').classList.add('show');
        document.getElementById('testName').value = '';
        document.getElementById('questionCount').value = 'all';
        document.getElementById('autoAnswers').checked = false;
    }

    function hashQuestions(questions) {
        // –ü—Ä–æ—Å—Ç–æ–π —Ö—ç—à –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –Ω–∞–±–æ—Ä–∞ –≤–æ–ø—Ä–æ—Å–æ–≤
        const str = questions.map(q => q.question).join('|');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return hash.toString();
    }

    function getSavedSettings(qHash) {
        const saved = JSON.parse(localStorage.getItem('quizMakerSettings')) || {};
        return saved[qHash];
    }

    function saveSettingsForHash(qHash) {
        const saved = JSON.parse(localStorage.getItem('quizMakerSettings')) || {};
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–∞–∫–∂–µ –≤–æ–ø—Ä–æ—Å—ã
        testSettings.questions = allParsedQuestions;
        saved[qHash] = testSettings;
        localStorage.setItem('quizMakerSettings', JSON.stringify(saved));
    }

    function closeSettingsModal() {
        document.getElementById('settingsModal').classList.remove('show');
    }

    function openAnswerSelectionModal() {
        const content = document.getElementById('answerSelectionContent');
        content.innerHTML = '';

        allParsedQuestions.forEach((q, idx) => {
            const qDiv = document.createElement('div');
            qDiv.style.marginBottom = '20px';
            qDiv.style.paddingBottom = '15px';
            qDiv.style.borderBottom = '1px solid rgba(255,255,255,0.1)';

            const qTitle = document.createElement('div');
            qTitle.style.fontWeight = '600';
            qTitle.style.marginBottom = '10px';
            qTitle.style.color = '#fbbf24';
            qTitle.textContent = `${idx + 1}. ${q.question}`;
            qDiv.appendChild(qTitle);

            q.variants.forEach((v, vIdx) => {
                const label = document.createElement('label');
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.marginBottom = '8px';
                label.style.cursor = 'pointer';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = vIdx;
                checkbox.dataset.questionId = idx;
                checkbox.style.marginRight = '10px';

                if (testSettings.selectedAnswerOverrides[idx] && testSettings.selectedAnswerOverrides[idx].includes(vIdx)) {
                    checkbox.checked = true;
                }

                const text = document.createElement('span');
                text.textContent = v.text;
                text.style.color = 'rgba(255,255,255,0.9)';

                label.appendChild(checkbox);
                label.appendChild(text);
                qDiv.appendChild(label);
            });

            content.appendChild(qDiv);
        });

        document.getElementById('answerSelectionModal').classList.add('show');
    }

    function closeAnswerSelectionModal() {
        document.getElementById('answerSelectionModal').classList.remove('show');
    }

    function saveSelectedAnswers() {
        testSettings.selectedAnswerOverrides = {};
        const checkboxes = document.getElementById('answerSelectionContent').querySelectorAll('input[type="checkbox"]');
        
        checkboxes.forEach(cb => {
            if (cb.checked) {
                const qId = parseInt(cb.dataset.questionId);
                const vIdx = parseInt(cb.value);
                
                if (!testSettings.selectedAnswerOverrides[qId]) {
                    testSettings.selectedAnswerOverrides[qId] = [];
                }
                testSettings.selectedAnswerOverrides[qId].push(vIdx);
            }
        });

        document.getElementById('answerSelectionStatus').textContent = '–î“±—Ä—ã—Å –∂–∞—É–∞–ø—Ç–∞—Ä —Å–∞“õ—Ç–∞–ª–¥—ã ‚úì';
        closeAnswerSelectionModal();
    }

    function startQuizWithSettings() {
        testSettings.testName = document.getElementById('testName').value || '–ê—Ç –µ–º–µ—Å —Ç–µ—Å—Ç';
        testSettings.questionCount = document.getElementById('questionCount').value;
        testSettings.autoAnswers = document.getElementById('autoAnswers').checked;

        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –≤–æ–ø—Ä–æ—Å–æ–≤
        const qHash = hashQuestions(allParsedQuestions);
        saveSettingsForHash(qHash);

        closeSettingsModal();
        startQuiz();
    }

    function saveTestToStorage() {
        // –ë–æ–ª—å—à–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∂–¥—ã–π –∑–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ saveSettingsForHash
    }

    function loadSavedTests() {
        const saved = JSON.parse(localStorage.getItem('quizMakerSettings')) || {};
        const container = document.getElementById('savedTestsContainer');
        const list = document.getElementById('savedTestsList');

        if (Object.keys(saved).length === 0) {
            container.style.display = 'none';
            return;
        }

        container.style.display = 'block';
        list.innerHTML = '';

        Object.entries(saved).forEach(([hash, settings]) => {
            const item = document.createElement('div');
            item.className = 'saved-test-item';
            item.style.display = 'flex';
            item.style.justifyContent = 'space-between';
            item.style.alignItems = 'center';
            
            const content = document.createElement('div');
            content.style.flex = '1';
            content.style.cursor = 'pointer';
            content.onclick = () => {
                // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å—ã –∏ –ø–æ–∫–∞–∑–∞—Ç—å –¥–∏–∞–ª–æ–≥ —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º
                allParsedQuestions = settings.questions || [];
                testSettings = JSON.parse(JSON.stringify(settings));
                
                if (allParsedQuestions.length === 0) {
                    alert('–í–æ–ø—Ä–æ—Å—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã!');
                    return;
                }

                // –ü–æ–∫–∞–∑–∞—Ç—å —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –¥–∏–∞–ª–æ–≥ —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∏ –∫–Ω–æ–ø–∫–æ–π —Å—Ç–∞—Ä—Ç
                showQuickStartDialog(settings);
            };
            
            const name = document.createElement('div');
            name.className = 'saved-test-name';
            name.textContent = settings.testName || '–ê—Ç –µ–º–µ—Å —Ç–µ—Å—Ç';

            const info = document.createElement('div');
            info.className = 'saved-test-info';
            info.textContent = `–°“±—Ä–∞“õ: ${settings.questionCount === 'all' ? '–ë–∞—Ä–ª—ã“ì—ã' : settings.questionCount}`;

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn-secondary';
            deleteBtn.textContent = '‚úï';
            deleteBtn.style.padding = '5px 10px';
            deleteBtn.style.fontSize = '14px';
            deleteBtn.style.marginLeft = '10px';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                if (confirm('–ë“±–ª —Ç–µ—Å—Ç—ñ–Ω—ñ“£ –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ–Ω –∂–æ—é –∫–µ—Ä–µ–∫ –ø–µ?')) {
                    deleteTestSettings(hash);
                }
            };

            content.appendChild(name);
            content.appendChild(info);
            item.appendChild(content);
            item.appendChild(deleteBtn);
            list.appendChild(item);
        });
    }

    function showQuickStartDialog(settings) {
        // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π –¥–∏–∞–ª–æ–≥ —Å –≤—ã–±–æ—Ä–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–æ–ø—Ä–æ—Å–æ–≤
        const dialog = document.createElement('div');
        dialog.className = 'modal show';
        dialog.id = 'quickStartModal';
        dialog.style.zIndex = '2000';
        dialog.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">‚öôÔ∏è –¢–µ—Å—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ</div>
                <div class="modal-field">
                    <label class="modal-label">–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤:</label>
                    <select id="quickQuestionCount">
                        <option value="all" ${settings.questionCount === 'all' ? 'selected' : ''}>–ë–∞—Ä–ª—ã“ì—ã (${allParsedQuestions.length})</option>
                        <option value="20" ${settings.questionCount === '20' ? 'selected' : ''}>–ú–∞–∫—Å 20</option>
                        <option value="50" ${settings.questionCount === '50' ? 'selected' : ''}>–ú–∞–∫—Å 50</option>
                    </select>
                </div>
                <div class="modal-buttons">
                    <button class="btn-secondary" onclick="document.getElementById('quickStartModal').remove();">–ë–∞—Å —Ç–∞—Ä—Ç—É</button>
                    <button class="btn-primary" onclick="startQuizFromQuickStart()">–ë–∞—Å—Ç—É</button>
                </div>
            </div>
        `;
        document.body.appendChild(dialog);
    }

    function startQuizFromQuickStart() {
        testSettings.questionCount = document.getElementById('quickQuestionCount').value;
        document.getElementById('quickStartModal').remove();
        startQuiz();
    }

    // SYSTEM TESTS FILES CONFIGURATION - –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è–π —Ñ–∞–π–ª—ã —Å—é–¥–∞
    const SYSTEM_TESTS = [
        { name: '–ê“õ–ø–∞—Ä–∞—Ç—Ç—ã“õ –ñ“Ø–π–µ–ª–µ—Ä –ú–æ–¥—É–ª—å 2', file: '–∞–∫–ø–∞—Ä–∞—Ç—Ç—ã–∫ –∂—É–π–µ–ª–µ—Ä.txt' },
        { name: '–ê“ì—ã–ª—à—ã–Ω –ú–æ–¥—É–ª—å 1', file: '–ê–Ω–≥_–ú–æ—É–¥–ª—å.txt' },
        // –î–æ–±–∞–≤—å –µ—â—ë —Ñ–∞–π–ª—ã:
        // { name: '–ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞ 2', file: 'file2.txt' },
        // { name: '–ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞ 3', file: 'file3.txt' }
    ];

    // SYSTEM TESTS: attempt to populate system tests linked to files
    function loadSystemTests() {
        const container = document.getElementById('systemTestsContainer');
        const list = document.getElementById('systemTestsList');
        list.innerHTML = '';

        // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ —Ç–µ—Å—Ç—ã –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        SYSTEM_TESTS.forEach((testConfig, index) => {
            const item = document.createElement('div');
            item.className = 'saved-test-item';
            item.style.cursor = 'pointer';
            item.onclick = () => startSystemTest(index);

            const name = document.createElement('div');
            name.className = 'saved-test-name';
            name.textContent = testConfig.name;

            const info = document.createElement('div');
            info.className = 'saved-test-info';
            info.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –≤–æ–ø—Ä–æ—Å–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞';

            item.appendChild(name);
            item.appendChild(info);
            list.appendChild(item);
        });

        container.style.display = 'block';
    }

    async function startSystemTest(fileIndex) {
        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Ñ–∞–π–ª–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É
        const testConfig = SYSTEM_TESTS[fileIndex];
        if (!testConfig) {
            alert('–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!');
            return;
        }

        // Try to fetch the file and parse questions, then show quick dialog
        const fileName = testConfig.file;
        const candidates = [
            `http://127.0.0.1:8000/${encodeURIComponent(fileName)}`,
            `http://127.0.0.1:8000/${fileName.replace(/\s+/g, '%20')}`,
            fileName,
            fileName.replace(/\s+/g, '%20')
        ];

        let text = null;
        for (const url of candidates) {
            try {
                const resp = await fetch(url);
                if (!resp.ok) throw new Error('not found');
                text = await resp.text();
                break;
            } catch (e) {
                // try next
            }
        }

        if (!text) {
            alert(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª: ${testConfig.name}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª "${fileName}" –¥–æ—Å—Ç—É–ø–µ–Ω.`);
            return;
        }

        allParsedQuestions = parseQuestions(text);
        if (allParsedQuestions.length === 0) {
            alert(`–í —Ñ–∞–π–ª–µ "${testConfig.name}" –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤–æ–ø—Ä–æ—Å–æ–≤.`);
            return;
        }

        // Show quick start dialog with default settings
        const settings = { questionCount: 'all', testName: testConfig.name };
        testSettings = settings;
        showQuickStartDialog(settings);
    }

    function deleteTestSettings(hash) {
        const saved = JSON.parse(localStorage.getItem('quizMakerSettings')) || {};
        delete saved[hash];
        localStorage.setItem('quizMakerSettings', JSON.stringify(saved));
        loadSavedTests();
        alert('–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–¥–∞–ª–µ–Ω—ã!');
    }

    // START QUIZ
    function startQuiz() {
        // Ensure testSettings defaults so missing fields (system tests) won't break
        testSettings = testSettings || {};
        testSettings.selectedAnswerOverrides = testSettings.selectedAnswerOverrides || {};
        testSettings.questionCount = testSettings.questionCount || 'all';

        // Use already loaded questions
        if (!allParsedQuestions || allParsedQuestions.length === 0) {
            alert('–°“±—Ä–∞“õ—Ç–∞—Ä –∑–∞–≥—Ä—É–∂–µ–Ω—ã –Ω–µ –±—ã–ª–∏!');
            return;
        }

        // Apply any overridden correct answers (if provided)
        questions = JSON.parse(JSON.stringify(allParsedQuestions));
        Object.keys(testSettings.selectedAnswerOverrides).forEach(qIdx => {
            const idx = parseInt(qIdx);
            if (questions[idx]) {
                questions[idx].variants.forEach((v, vIdx) => {
                    v.isCorrect = (testSettings.selectedAnswerOverrides[idx] || []).includes(vIdx);
                });
            }
        });

        // –§–∏–ª—å—Ç—Ä—É–µ–º –≤–æ–ø—Ä–æ—Å—ã –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º)
        if (!isRetryingWrongAnswers) {
            if (testSettings.questionCount === '20' && questions.length > 20) {
                questions = shuffle(questions).slice(0, 20);
            } else if (testSettings.questionCount === '50' && questions.length > 50) {
                questions = shuffle(questions).slice(0, 50);
            }

            // –î–æ–ø–æ–ª–Ω–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–æ 5 —à—Ç—É–∫
            questions = ensureMinimumVariants(questions);

            // Shuffle questions and variants
            questions = shuffle(questions);
            questions.forEach(q => {
                q.variants = shuffle(q.variants);
            });
        }

        // Reset state
        currentQuestionIndex = 0;
        userAnswers = new Array(questions.length).fill(null);
        questionAnswerStates = new Array(questions.length).fill(false);
        answeredQuestions = 0;
        wrongQuestionIndices = [];
        isRetryingWrongAnswers = false;

        // Show quiz screen
        document.getElementById('inputScreen').classList.add('hidden');
        document.getElementById('quizScreen').classList.remove('hidden');

        document.getElementById('totalQuestions').textContent = questions.length;
        displayQuestion();
    }

    // Attempt auto-load when page is ready
    window.addEventListener('DOMContentLoaded', () => {
        // –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞
    });

    // DISPLAY CURRENT QUESTION
    function displayQuestion() {
        const q = questions[currentQuestionIndex];

        document.getElementById('questionNumber').textContent = currentQuestionIndex + 1;
        
        // Build question text with type indicator
        let questionTypeLabel = '';
        if (q.type === 'question') {
            questionTypeLabel = '(–í–æ–ø—Ä–æ—Å —Å 1 –≤–µ—Ä–Ω—ã–º –æ—Ç–≤–µ—Ç–æ–º)';
        } else if (q.type === 'question2') {
            const correctCount = q.variants.filter(v => v.isCorrect).length;
            questionTypeLabel = `(–í–æ–ø—Ä–æ—Å —Å ${correctCount} –≤–µ—Ä–Ω—ã–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏)`;
        } else if (q.type === 'question3') {
            const correctCount = q.variants.filter(v => v.isCorrect).length;
            questionTypeLabel = `(–í–æ–ø—Ä–æ—Å —Å ${correctCount} –≤–µ—Ä–Ω—ã–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏)`;
        }
        
        document.getElementById('questionText').textContent = q.question;
        
        // Add type indicator
        const questionContainer = document.querySelector('.question-container');
        let typeIndicator = questionContainer.querySelector('.question-type-label');
        
        if (!typeIndicator) {
            typeIndicator = document.createElement('div');
            typeIndicator.className = 'question-type-label';
            questionContainer.insertBefore(typeIndicator, document.getElementById('optionsContainer'));
        }
        typeIndicator.textContent = questionTypeLabel;

        const optionsContainer = document.getElementById('optionsContainer');
        optionsContainer.innerHTML = '';

        const feedback = document.getElementById('feedbackMessage');
        feedback.classList.remove('show', 'feedback-correct', 'feedback-incorrect');

        const skipBtn = document.getElementById('skipBtn');
        const nextBtn = document.getElementById('nextBtn');
        if (skipBtn) skipBtn.style.display = 'none';
        if (nextBtn) nextBtn.disabled = false;

        // Determine input type based on question type
        const isMultipleChoice = q.type !== 'question';

        // If question has no variants, show notice and let user skip manually
        if (!q.variants || q.variants.length === 0) {
            const notice = document.createElement('div');
            notice.className = 'option disabled';
            notice.style.border = '2px dashed rgba(255,255,255,0.1)';
            notice.style.background = 'rgba(255,255,255,0.02)';
            notice.style.color = 'rgba(255,255,255,0.8)';
            notice.style.fontStyle = 'italic';
            notice.textContent = '–ë“±–ª —Å“±—Ä–∞“õ—Ç–∞ –∂–∞—É–∞–ø –≤–∞—Ä–∏–∞–Ω—Ç—Ç–∞—Ä—ã –∂–æ“õ ‚Äî —Å“±—Ä–∞“õ—Ç—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.';
            optionsContainer.appendChild(notice);

            // Show neutral feedback and enable skip button
            feedback.classList.add('show');
            feedback.classList.remove('feedback-correct', 'feedback-incorrect');
            feedback.textContent = '–£ —ç—Ç–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –Ω–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ ‚Äî –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –¥–∞–ª—å—à–µ.';

            if (skipBtn) skipBtn.style.display = 'inline-block';
            if (nextBtn) nextBtn.disabled = true;

            return;
        }

        q.variants.forEach((variant, idx) => {
            const label = document.createElement('label');
            label.className = 'option';

            const input = document.createElement('input');
            input.type = isMultipleChoice ? 'checkbox' : 'radio';
            input.name = isMultipleChoice ? `answer-${currentQuestionIndex}` : `answer-${currentQuestionIndex}`;
            input.value = idx;
            input.id = `opt-${currentQuestionIndex}-${idx}`;

            // Initialize userAnswers structure if needed
            if (isMultipleChoice) {
                if (!Array.isArray(userAnswers[currentQuestionIndex])) {
                    userAnswers[currentQuestionIndex] = [];
                }
                if (userAnswers[currentQuestionIndex].includes(idx)) {
                    input.checked = true;
                    label.classList.add('selected');
                }
            } else {
                if (userAnswers[currentQuestionIndex] === idx) {
                    input.checked = true;
                    label.classList.add('selected');
                }
            }

            const text = document.createElement('span');
            text.textContent = variant.text;

            label.appendChild(input);
            label.appendChild(text);

            // Use input change event to keep DOM state and internal state in sync
            input.addEventListener('change', (e) => {
                if (label.classList.contains('disabled')) {
                    // prevent changes if disabled (after checking)
                    e.preventDefault();
                    // restore checked state to reflect current userAnswers
                    if (isMultipleChoice) {
                        input.checked = userAnswers[currentQuestionIndex] && userAnswers[currentQuestionIndex].includes(idx);
                    } else {
                        input.checked = userAnswers[currentQuestionIndex] === idx;
                    }
                    return;
                }

                if (isMultipleChoice) {
                    selectAnswer(idx, input.checked);
                } else {
                    selectAnswer(idx, true);
                }
            });

            optionsContainer.appendChild(label);
        });

        // If this question was already answered earlier, reveal the answer state
        if (questionAnswerStates[currentQuestionIndex]) {
            revealAnswerForQuestion(currentQuestionIndex);
        }

        // Update button text
        document.getElementById('nextBtn').textContent = currentQuestionIndex === questions.length - 1 
            ? '–ê—è“õ—Ç–∞—É' 
            : '–ö–µ–ª–µ—Å—ñ —Å“±—Ä–∞“õ';
    }

    // SELECT ANSWER
    function selectAnswer(variantIndex) {
        const q = questions[currentQuestionIndex];

        // Support being called with (variantIndex, checked)
        let checked = null;
        if (arguments.length > 1) checked = arguments[1];

        // For single-choice questions (question type)
        if (q.type === 'question') {
            userAnswers[currentQuestionIndex] = variantIndex;

            const optionsContainer = document.getElementById('optionsContainer');
            const optionLabels = optionsContainer.querySelectorAll('label');

            optionLabels.forEach((label, idx) => {
                const input = label.querySelector('input');
                if (idx === variantIndex) {
                    label.classList.add('selected');
                    if (input) input.checked = true;
                } else {
                    label.classList.remove('selected');
                    if (input) input.checked = false;
                }
            });
        } else {
            // Multiple choice
            if (!Array.isArray(userAnswers[currentQuestionIndex])) {
                userAnswers[currentQuestionIndex] = [];
            }

            const selected = userAnswers[currentQuestionIndex];

            if (checked === null) {
                // toggle if checked not provided
                const pos = selected.indexOf(variantIndex);
                if (pos > -1) {
                    selected.splice(pos, 1);
                } else {
                    selected.push(variantIndex);
                }
            } else {
                const pos = selected.indexOf(variantIndex);
                if (checked && pos === -1) {
                    selected.push(variantIndex);
                } else if (!checked && pos > -1) {
                    selected.splice(pos, 1);
                }
            }

            // Update UI
            const optionsContainer = document.getElementById('optionsContainer');
            const optionLabels = optionsContainer.querySelectorAll('label');

            optionLabels.forEach((label, idx) => {
                const input = label.querySelector('input');
                if (selected.includes(idx)) {
                    label.classList.add('selected');
                    if (input) input.checked = true;
                } else {
                    label.classList.remove('selected');
                    if (input) input.checked = false;
                }
            });
        }
    }

    // Reveal answer for a question without alerting (used when going back or showing history)
    function revealAnswerForQuestion(index) {
        const q = questions[index];
        const optionsContainer = document.getElementById('optionsContainer');
        const optionLabels = optionsContainer.querySelectorAll('label');
        const feedback = document.getElementById('feedbackMessage');

        let isCorrect = false;

        if (q.type === 'question') {
            const selectedIdx = userAnswers[index];
            isCorrect = selectedIdx !== null && selectedIdx !== undefined && q.variants[selectedIdx] && q.variants[selectedIdx].isCorrect;
        } else {
            const selectedIndices = userAnswers[index] || [];
            const correctIndices = q.variants.map((v, i) => v.isCorrect ? i : -1).filter(i => i !== -1);
            isCorrect = selectedIndices.length === correctIndices.length && selectedIndices.every(i => q.variants[i].isCorrect);
        }

        // Show feedback
        feedback.classList.add('show');
        feedback.classList.remove('feedback-correct', 'feedback-incorrect');
        feedback.classList.add(isCorrect ? 'feedback-correct' : 'feedback-incorrect');
        feedback.textContent = isCorrect ? '‚úì –î“±—Ä—ã—Å –∂–∞—É–∞–ø!' : '‚úó “ö–∞—Ç–µ –∂–∞—É–∞–ø!';

        // Style options
        optionLabels.forEach((label, idx) => {
            label.classList.add('disabled');
            if (q.variants[idx].isCorrect) {
                label.classList.add('correct');
            } else if (Array.isArray(userAnswers[index]) ? userAnswers[index].includes(idx) : userAnswers[index] === idx) {
                label.classList.add('incorrect');
            }
        });
    }

    // SHOW FEEDBACK
    function showFeedback(isCorrect) {
        const feedback = document.getElementById('feedbackMessage');
        feedback.classList.add('show');
        feedback.classList.add(isCorrect ? 'feedback-correct' : 'feedback-incorrect');
        feedback.textContent = isCorrect ? '‚úì –î“±—Ä—ã—Å –∂–∞—É–∞–ø!' : '‚úó “ö–∞—Ç–µ –∂–∞—É–∞–ø!';
    }

    // CHECK ANSWER AND SHOW FEEDBACK
    function checkCurrentAnswer() {
        const q = questions[currentQuestionIndex];
        const feedback = document.getElementById('feedbackMessage');
        
        if (q.type === 'question') {
            // Single choice
            if (userAnswers[currentQuestionIndex] === null || userAnswers[currentQuestionIndex] === undefined) {
                alert('–ñ–∞—É–∞–ø —Ç–∞“£–¥–∞“£—ã–∑!');
                return false;
            }

            const selectedIdx = userAnswers[currentQuestionIndex];
            let isCorrect = false;
            if (selectedIdx !== null && selectedIdx !== undefined && q.variants[selectedIdx]) {
                isCorrect = !!q.variants[selectedIdx].isCorrect;
            }

            // Show feedback
            feedback.classList.add('show');
            feedback.classList.remove('feedback-correct', 'feedback-incorrect');
            feedback.classList.add(isCorrect ? 'feedback-correct' : 'feedback-incorrect');
            feedback.textContent = isCorrect ? '‚úì –î“±—Ä—ã—Å –∂–∞—É–∞–ø!' : '‚úó “ö–∞—Ç–µ –∂–∞—É–∞–ø!';

            // Style options
            const optionsContainer = document.getElementById('optionsContainer');
            const optionLabels = optionsContainer.querySelectorAll('label');

            optionLabels.forEach((label, idx) => {
                label.classList.add('disabled');
                if (idx === selectedIdx) {
                    label.classList.add(isCorrect ? 'correct' : 'incorrect');
                } else if (q.variants[idx].isCorrect) {
                    label.classList.add('correct');
                } else {
                    label.classList.remove('correct', 'incorrect');
                }
            });

            // Mark question as answered
            if (!questionAnswerStates[currentQuestionIndex]) {
                questionAnswerStates[currentQuestionIndex] = true;
                answeredQuestions++;
            }

            return true;
        } else {
            // Multiple choice
            const selectedIndices = userAnswers[currentQuestionIndex];
            
            if (!selectedIndices || !Array.isArray(selectedIndices) || selectedIndices.length === 0) {
                alert('–ñ–∞—É–∞–ø —Ç–∞“£–¥–∞“£—ã–∑!');
                return false;
            }

            const correctIndices = q.variants
                .map((v, idx) => v.isCorrect ? idx : -1)
                .filter(idx => idx !== -1);

            // Check if all correct answers are selected and no wrong answers are selected
            const isCorrect = selectedIndices.length === correctIndices.length &&
                selectedIndices.every(idx => q.variants[idx].isCorrect);

            // Show feedback
            feedback.classList.add('show');
            feedback.classList.add(isCorrect ? 'feedback-correct' : 'feedback-incorrect');
            feedback.textContent = isCorrect ? '‚úì –î“±—Ä—ã—Å –∂–∞—É–∞–ø!' : '‚úó “ö–∞—Ç–µ –∂–∞—É–∞–ø!';

            // Style options
            const optionsContainer = document.getElementById('optionsContainer');
            const optionLabels = optionsContainer.querySelectorAll('label');

            optionLabels.forEach((label, idx) => {
                label.classList.add('disabled');
                if (q.variants[idx].isCorrect) {
                    label.classList.add('correct');
                } else if (selectedIndices.includes(idx)) {
                    label.classList.add('incorrect');
                }
            });

            // Mark question as answered
            if (!questionAnswerStates[currentQuestionIndex]) {
                questionAnswerStates[currentQuestionIndex] = true;
                answeredQuestions++;
            }

            return true;
        }
    }

    // UPDATE STATS
    function updateStats() {
        let correctCount = 0;
        let answeredCount = 0;

        questions.forEach((q, idx) => {
            if (userAnswers[idx] === null || userAnswers[idx] === undefined || 
                (Array.isArray(userAnswers[idx]) && userAnswers[idx].length === 0)) {
                return;
            }

            answeredCount++;

            if (q.type === 'question') {
                // Single choice
                const sel = userAnswers[idx];
                if (sel !== null && sel !== undefined && q.variants[sel] && q.variants[sel].isCorrect) {
                    correctCount++;
                }
            } else {
                // Multiple choice
                const selectedIndices = userAnswers[idx];
                const correctIndices = q.variants
                    .map((v, i) => v.isCorrect ? i : -1)
                    .filter(i => i !== -1);

                if (selectedIndices.length === correctIndices.length &&
                    selectedIndices.every(i => q.variants[i].isCorrect)) {
                    correctCount++;
                }
            }
        });

        document.getElementById('correctCount').textContent = correctCount;
        document.getElementById('incorrectCount').textContent = answeredCount - correctCount;
    }

    // CALCULATE SCORE
    function calculateScore() {
        let totalScore = 0;

        questions.forEach((q, idx) => {
            if (userAnswers[idx] === null || userAnswers[idx] === undefined || 
                (Array.isArray(userAnswers[idx]) && userAnswers[idx].length === 0)) {
                return;
            }

            let isCorrect = false;

            if (q.type === 'question') {
                const sel = userAnswers[idx];
                if (sel !== null && sel !== undefined && q.variants[sel] && q.variants[sel].isCorrect) {
                    isCorrect = true;
                    totalScore += 5;
                }
            } else {
                // Multiple choice
                const selectedIndices = userAnswers[idx];
                const correctIndices = q.variants
                    .map((v, i) => v.isCorrect ? i : -1)
                    .filter(i => i !== -1);

                // Award points per correctly selected option (no penalty for wrong selections)
                const perCorrect = correctIndices.length > 0 ? (5 / correctIndices.length) : 0;
                selectedIndices.forEach(si => {
                    if (q.variants[si] && q.variants[si].isCorrect) {
                        totalScore += perCorrect;
                    }
                });
            }
        });

        return totalScore;
    }

    // NEXT QUESTION
    function nextQuestion() {
        const q = questions[currentQuestionIndex];
        const feedback = document.getElementById('feedbackMessage');

        // If feedback is not shown yet, check answer first
        if (!feedback.classList.contains('show')) {
            checkCurrentAnswer();
            updateStats();
            return;
        }

        // Feedback is already shown, move to next question
        if (currentQuestionIndex === questions.length - 1) {
            showResults();
            return;
        }

        currentQuestionIndex++;
        // Reset feedback message for next question
        feedback.classList.remove('show', 'feedback-correct', 'feedback-incorrect');
        displayQuestion();
    }

    // GO BACK
    function goBack() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            // Reset feedback message
            const feedback = document.getElementById('feedbackMessage');
            feedback.classList.remove('show', 'feedback-correct', 'feedback-incorrect');
            displayQuestion();
        }
    }

    // SKIP QUESTION (user triggered)
    function skipQuestion() {
        const feedback = document.getElementById('feedbackMessage');
        feedback.classList.remove('show', 'feedback-correct', 'feedback-incorrect');

        const skipBtn = document.getElementById('skipBtn');
        const nextBtn = document.getElementById('nextBtn');
        if (skipBtn) skipBtn.style.display = 'none';
        if (nextBtn) nextBtn.disabled = false;

        if (currentQuestionIndex === questions.length - 1) {
            showResults();
            return;
        }

        currentQuestionIndex++;
        displayQuestion();
    }

    // SHOW RESULTS
    function showResults() {
        document.getElementById('quizScreen').classList.add('hidden');
        document.getElementById('resultsScreen').classList.remove('hidden');

        const totalScore = calculateScore();
        const maxScore = questions.length * 5;

         // Round displayed total score to whole points
        const roundedScore = Math.round(totalScore);
        const percentage = Math.round((roundedScore / maxScore) * 100);

        document.getElementById('finalScore').textContent = `${roundedScore}/${maxScore}`;
        document.getElementById('resultMessage').textContent = `–°—ñ–∑–¥—ñ“£ –Ω”ô—Ç–∏–∂–µ“£—ñ–∑: ${percentage}%`;

        // –ü–æ—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤
        let correctQuestions = 0;
        let answeredQuestionsCount = 0;
        wrongQuestionIndices = [];

        questions.forEach((q, idx) => {
            const ua = userAnswers[idx];
            if (ua === null || ua === undefined || (Array.isArray(ua) && ua.length === 0)) {
                return; // –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –Ω–µ–æ—Ç–≤–µ—á–µ–Ω–Ω—ã–µ
            }

            answeredQuestionsCount++;

            let isCorrect = false;
            if (q.type === 'question') {
                if (ua !== null && ua !== undefined && q.variants[ua] && q.variants[ua].isCorrect) {
                    isCorrect = true;
                    correctQuestions++;
                }
            } else {
                const selectedIndices = ua || [];
                const correctIndices = q.variants
                    .map((v, i) => v.isCorrect ? i : -1)
                    .filter(i => i !== -1);

                if (selectedIndices.length === correctIndices.length &&
                    selectedIndices.every(i => q.variants[i] && q.variants[i].isCorrect)) {
                    isCorrect = true;
                    correctQuestions++;
                }
            }

            // –ï—Å–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ, —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–∞–º –≤–æ–ø—Ä–æ—Å
            if (!isCorrect) {
                wrongQuestionIndices.push(q);
            }
        });

        const incorrectQuestions = answeredQuestionsCount - correctQuestions;
        const resultsCounts = document.getElementById('resultsCounts');
        if (resultsCounts) {
            resultsCounts.textContent = `–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö: ${correctQuestions} ‚Ä¢ –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö: ${incorrectQuestions}`;
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö
        const retryBtn = document.getElementById('retryWrongBtn');
        if (wrongQuestionIndices.length > 0) {
            retryBtn.style.display = 'block';
        } else {
            retryBtn.style.display = 'none';
        }

        // Display result items
        const resultsList = document.getElementById('resultsList');
        resultsList.innerHTML = '';

        questions.forEach((q, idx) => {
            let isCorrect = false;
            let userAnswerText = '';
            let correctAnswers = [];
            let allAnswers = [];

            const isNoVariants = !q.variants || q.variants.length === 0;

            // Get all variants for display
            if (!isNoVariants) {
                allAnswers = q.variants.map((v, vIdx) => ({ text: v.text, idx: vIdx, isCorrect: v.isCorrect }));
                correctAnswers = q.variants.filter(v => v.isCorrect).map(v => v.text);
            } else {
                allAnswers = [];
                correctAnswers = [];
            }

            if (isNoVariants) {
                userAnswerText = '–°“±—Ä–∞“õ—Ç–∞ –≤–∞—Ä–∏–∞–Ω—Ç—Ç–∞—Ä –∂–æ“õ ‚Äî –ø—Ä–æ–ø—É—â–µ–Ω';
                isCorrect = false;
            } else if (q.type === 'question') {
                // Single choice
                if (userAnswers[idx] !== null && userAnswers[idx] !== undefined) {
                    userAnswerText = q.variants[userAnswers[idx]].text;
                    isCorrect = q.variants[userAnswers[idx]].isCorrect;
                }
            } else {
                // Multiple choice
                const selectedIndices = userAnswers[idx];
                if (selectedIndices && selectedIndices.length > 0) {
                    const selectedAnswers = selectedIndices.map(i => q.variants[i]);
                    userAnswerText = selectedAnswers.map(a => a.text).join(', ');

                    const correctIndices = q.variants
                        .map((v, i) => v.isCorrect ? i : -1)
                        .filter(i => i !== -1);

                    isCorrect = selectedIndices.length === correctIndices.length &&
                        selectedIndices.every(i => q.variants[i].isCorrect);
                }
            }

            const resultItem = document.createElement('div');
            resultItem.className = `result-item ${isCorrect ? 'correct' : 'incorrect'}`;

            let content = `<div class="result-number">${isCorrect ? '‚úì –î“±—Ä—ã—Å' : '‚úó “ö–∞—Ç–µ'} —Å“±—Ä–∞“õ ${idx + 1}</div>`;
            content += `<div class="result-question">${q.question}</div>`;
            
            // Show all answer options (or note there are none)
            content += `<div style="margin: 12px 0 8px 0; font-size: 12px; color: rgba(255,255,255,0.6); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">–ë–∞—Ä–ª—ã“õ –≤–∞—Ä–∏–∞–Ω—Ç—Ç–∞—Ä:</div>`;
            
            if (isNoVariants) {
                content += `<div class="result-unselected-answer" style="padding:10px;">(–í–æ–ø—Ä–æ—Å –Ω–µ —Å–æ–¥–µ—Ä–∂–∞–ª –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏ –±—ã–ª –ø—Ä–æ–ø—É—â–µ–Ω)</div>`;
            } else {
                allAnswers.forEach((answer) => {
                const isCorrectAnswer = answer.isCorrect;
                const isUserSelected = userAnswers[idx] && 
                    (q.type === 'question' ? userAnswers[idx] === answer.idx : userAnswers[idx].includes(answer.idx));
                
                let answerClass = 'result-answer';
                let indicator = '‚óã';
                
                if (isCorrectAnswer && isUserSelected) {
                    answerClass += ' result-correct-answer';
                    indicator = '‚úì';
                } else if (isCorrectAnswer && !isUserSelected) {
                    answerClass += ' result-correct-answer';
                    indicator = '‚úì';
                } else if (!isCorrectAnswer && isUserSelected) {
                    answerClass += ' result-user-answer';
                    indicator = '‚úó';
                } else {
                    answerClass += ' result-unselected-answer';
                    indicator = '‚óã';
                }
                
                content += `<div class="${answerClass}"><span class="result-icon">${indicator}</span>${answer.text}</div>`;
                });
            }
            
            content += `<div style="margin-top: 12px; font-weight: 600; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;\"><span class="result-icon" style="color: #fbbf24;\">‚Üí</span> –°—ñ–∑–¥—ñ“£ –∂–∞—É–∞–ø: ${userAnswerText || '–ñ–∞—É–∞–ø –±–µ—Ä—ñ–ª–º–µ–≥–µ–Ω'}</div>`;

            resultItem.innerHTML = content;
            resultsList.appendChild(resultItem);
        });
    }

    // RESTART QUIZ
    function restartQuiz() {
        currentQuestionIndex = 0;
        userAnswers = [];
        answeredQuestions = 0;
        questionAnswerStates = [];

        document.getElementById('inputScreen').classList.remove('hidden');
        document.getElementById('resultsScreen').classList.add('hidden');
        document.getElementById('questionsInput').value = '';
        
        loadSavedTests();
    }

    // RETRY WITH WRONG ANSWERS
    // RETRY WITH WRONG ANSWERS
    function retryWrongAnswers() {
        if (wrongQuestionIndices.length === 0) {
            alert('–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ!');
            return;
        }

        currentQuestionIndex = 0;
        userAnswers = new Array(wrongQuestionIndices.length).fill(null);
        questionAnswerStates = new Array(wrongQuestionIndices.length).fill(false);
        answeredQuestions = 0;

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤ –≤–æ–ø—Ä–æ—Å–æ–≤ —Ç–æ–ª—å–∫–æ –∏–∑ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö
        // wrongQuestionIndices —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–∞–º–∏ –æ–±—ä–µ–∫—Ç—ã –≤–æ–ø—Ä–æ—Å–æ–≤, –∞ –Ω–µ –∏–Ω–¥–µ–∫—Å—ã
        questions = wrongQuestionIndices.map(q => JSON.parse(JSON.stringify(q)));
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–æ 5
        questions = ensureMinimumVariants(questions);
        
        // –ü–µ—Ä–µ–º–µ—à–∞—Ç—å
        questions = shuffle(questions);
        questions.forEach(q => {
            q.variants = shuffle(q.variants);
        });

        document.getElementById('resultsScreen').classList.add('hidden');
        document.getElementById('quizScreen').classList.remove('hidden');
        document.getElementById('totalQuestions').textContent = questions.length;
        
        displayQuestion();
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', () => {
        loadSavedTests();
        loadSystemTests();
    });
</script>

</body>
</html>
